import 'package:flutter_openapi_generator/src/config/generator_config.dart';
import 'package:flutter_openapi_generator/src/models/model_definition.dart';

class ModelGenerator {
  String generateModel(ModelDefinition model, GeneratorConfig config) {
    final className = '${model.name}${config.naming.modelSuffix}';
    final buffer = StringBuffer();

    // File header
    buffer.writeln('// Generated file. Do not edit.');
    buffer.writeln('// This file was generated by Flutter OpenAPI Generator');
    buffer.writeln('');

    // Add imports for referenced models
    final imports = _getModelImports(model, config);
    for (final import in imports) {
      buffer.writeln('import \'$import\';');
    }
    if (imports.isNotEmpty) {
      buffer.writeln('');
    }

    // Class definition
    buffer.writeln('class $className {');

    // Properties
    for (final property in model.properties) {
      buffer.writeln('  final ${property.type} ${property.name};');
    }
    buffer.writeln('');

    // Constructor
    buffer.write('  const $className({');
    for (int i = 0; i < model.properties.length; i++) {
      final property = model.properties[i];
      if (property.isRequired) {
        buffer.write('required ${property.type} this.${property.name}');
      } else {
        buffer.write('${property.type} this.${property.name}');
      }
      if (i < model.properties.length - 1) {
        buffer.write(', ');
      }
    }
    buffer.writeln('});');
    buffer.writeln('');

    // fromJson factory constructor
    buffer
        .writeln('  factory $className.fromJson(Map<String, dynamic> json) {');
    buffer.writeln('    return $className(');
    for (int i = 0; i < model.properties.length; i++) {
      final property = model.properties[i];
      final jsonAccess = _generateJsonAccess(property);
      buffer.write('      ${property.name}: $jsonAccess');
      if (i < model.properties.length - 1) {
        buffer.write(',');
      }
      buffer.writeln();
    }
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('');

    // toJson method (if enabled)
    if (config.generation.addToJson) {
      buffer.writeln('  Map<String, dynamic> toJson() {');
      buffer.writeln('    return {');
      for (int i = 0; i < model.properties.length; i++) {
        final property = model.properties[i];
        buffer.write('      \'${property.name}\': ${property.name}');
        if (i < model.properties.length - 1) {
          buffer.write(',');
        }
        buffer.writeln();
      }
      buffer.writeln('    };');
      buffer.writeln('  }');
      buffer.writeln('');
    }

    // toString method (if enabled)
    if (config.features.generateToString) {
      buffer.writeln('  @override');
      buffer.writeln('  String toString() {');
      buffer.write('    return \'$className(');
      for (int i = 0; i < model.properties.length; i++) {
        final property = model.properties[i];
        buffer.write('${property.name}: \${${property.name}}');
        if (i < model.properties.length - 1) {
          buffer.write(', ');
        }
      }
      buffer.writeln(')\';');
      buffer.writeln('  }');
      buffer.writeln('');
    }

    // Equality (if enabled)
    if (config.features.generateEquality) {
      buffer.writeln('  @override');
      buffer.writeln('  bool operator ==(Object other) {');
      buffer.writeln('    if (identical(this, other)) return true;');
      buffer.writeln('    return other is $className &&');
      for (int i = 0; i < model.properties.length; i++) {
        final property = model.properties[i];
        buffer.write('        ${property.name} == other.${property.name}');
        if (i < model.properties.length - 1) {
          buffer.write(' &&');
        }
        buffer.writeln();
      }
      buffer.writeln('    ;');
      buffer.writeln('  }');
      buffer.writeln('');

      buffer.writeln('  @override');
      buffer.writeln('  int get hashCode {');
      buffer.write('    return ');
      for (int i = 0; i < model.properties.length; i++) {
        final property = model.properties[i];
        buffer.write('${property.name}.hashCode');
        if (i < model.properties.length - 1) {
          buffer.write(' ^ ');
        }
      }
      buffer.writeln(';');
      buffer.writeln('  }');
      buffer.writeln('');
    }

    // copyWith method (if enabled)
    if (config.features.generateCopyWith) {
      buffer.writeln('  $className copyWith({');
      for (final property in model.properties) {
        buffer.writeln('    ${property.type}? ${property.name},');
      }
      buffer.writeln('  }) {');
      buffer.writeln('    return $className(');
      for (final property in model.properties) {
        buffer.writeln(
            '      ${property.name}: ${property.name} ?? this.${property.name},');
      }
      buffer.writeln('    );');
      buffer.writeln('  }');
      buffer.writeln('');
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  String _generateJsonAccess(ModelProperty property) {
    final type = property.type.replaceAll('?', '');

    switch (type) {
      case 'String':
        return property.isRequired
            ? 'json[\'${property.name}\']?.toString() ?? \'\''
            : 'json[\'${property.name}\']?.toString()';
      case 'int':
        return property.isRequired
            ? 'json[\'${property.name}\']?.toInt() ?? 0'
            : 'json[\'${property.name}\']?.toInt()';
      case 'double':
        return property.isRequired
            ? 'json[\'${property.name}\']?.toDouble() ?? 0.0'
            : 'json[\'${property.name}\']?.toDouble()';
      case 'bool':
        return property.isRequired
            ? 'json[\'${property.name}\'] ?? false'
            : 'json[\'${property.name}\']';
      case 'DateTime':
        return property.isRequired
            ? 'json[\'${property.name}\'] != null ? DateTime.parse(json[\'${property.name}\']) : DateTime.now()'
            : 'json[\'${property.name}\'] != null ? DateTime.parse(json[\'${property.name}\']) : null';
      default:
        if (type.startsWith('List<')) {
          final itemType = type.substring(5, type.length - 1);
          if (_isPrimitiveType(itemType)) {
            return property.isRequired
                ? 'json[\'${property.name}\'] != null ? List<${itemType}>.from(json[\'${property.name}\']) : []'
                : 'json[\'${property.name}\'] != null ? List<${itemType}>.from(json[\'${property.name}\']) : null';
          } else {
            return property.isRequired
                ? 'json[\'${property.name}\'] != null ? List<${itemType}>.from(json[\'${property.name}\'].map((x) => ${itemType}.fromJson(x))) : []'
                : 'json[\'${property.name}\'] != null ? List<${itemType}>.from(json[\'${property.name}\'].map((x) => ${itemType}.fromJson(x))) : null';
          }
        } else if (type.startsWith('Map<')) {
          return property.isRequired
              ? 'json[\'${property.name}\'] != null ? Map<String, dynamic>.from(json[\'${property.name}\']) : {}'
              : 'json[\'${property.name}\'] != null ? Map<String, dynamic>.from(json[\'${property.name}\']) : null';
        } else {
          if (type == 'dynamic') {
            return 'json[\'${property.name}\']';
          } else if (property.isRequired) {
            return 'json[\'${property.name}\'] != null ? ${type}.fromJson(json[\'${property.name}\']) : (throw ArgumentError(\'Missing required field: ${property.name}\'))';
          } else {
            return 'json[\'${property.name}\'] != null ? ${type}.fromJson(json[\'${property.name}\']) : null';
          }
        }
    }
  }

  List<String> _getModelImports(ModelDefinition model, GeneratorConfig config) {
    final imports = <String>{};

    for (final property in model.properties) {
      final type = property.type.replaceAll('?', '');

      // Check if this is a custom model type (not a primitive or built-in type)
      if (!_isPrimitiveType(type) &&
          !type.startsWith('List<') &&
          !type.startsWith('Map<')) {
        final fileName = _toSnakeCase(type) + '.dart';
        imports.add(fileName);
      } else if (type.startsWith('List<')) {
        // Extract the item type from List<T>
        final itemType = type.substring(5, type.length - 1);
        if (!_isPrimitiveType(itemType) && !itemType.startsWith('Map<')) {
          final fileName = _toSnakeCase(itemType) + '.dart';
          imports.add(fileName);
        }
      }
    }

    return imports.toList()..sort();
  }

  bool _isPrimitiveType(String type) {
    return ['String', 'int', 'double', 'bool', 'DateTime', 'dynamic']
        .contains(type);
  }

  String _toSnakeCase(String input) {
    return input
        .replaceAllMapped(
          RegExp(r'([A-Z])'),
          (match) => '_${match[1]!.toLowerCase()}',
        )
        .toLowerCase()
        .replaceFirst(RegExp(r'^_'), '');
  }
}
